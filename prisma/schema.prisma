generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Category {
  id         Int        @id @default(autoincrement())
  name       String
  parent_id  Int?
  note       String?    @db.VarChar(1024)
  parent     Category?  @relation("nestedCategories", fields: [parent_id], references: [id], onDelete: Cascade)
  categories Category[] @relation("nestedCategories")
  features   Feature[]

  @@map("categories")
}

model Product {
  id               Int              @id @default(autoincrement())
  name             String           @unique
  note             String?          @db.VarChar(1024)
  code_name        String?
  product_features ProductFeature[]
  product_versions ProductVersion[]

  @@map("products")
}

model Feature {
  id               Int              @id @default(autoincrement())
  name             String
  category_id      Int
  note             String?          @db.VarChar(1024)
  categories       Category         @relation(fields: [category_id], references: [id], onDelete: Cascade)
  product_features ProductFeature[]

  @@map("features")
}

model ProductFeature {
  id                    Int                  @id @default(autoincrement())
  product_id            Int
  feature_id            Int
  implementation_status ImplementationStatus
  note                  String?              @db.VarChar(1024)
  release_id            Int?
  feature               Feature              @relation(fields: [feature_id], references: [id], onDelete: Cascade)
  product               Product              @relation(fields: [product_id], references: [id], onDelete: Cascade)
  release               Release?             @relation(fields: [release_id], references: [id], onDelete: Cascade)
  product_features_B    ProductFeature[]     @relation("dependencies")
  product_features_A    ProductFeature[]     @relation("dependencies")

  @@unique([product_id, feature_id])
  @@map("product_features")
}

model Release {
  id                   Int                @id @default(autoincrement())
  name                 String
  general_availability DateTime?
  released             Boolean
  end_of_development   DateTime?
  end_of_life          DateTime?
  end_of_sales         DateTime?
  end_of_service       DateTime?
  end_of_support       DateTime?
  product_features     ProductFeature[]
  product_lifecycles   ProductLifecycle[]
  release_versions     ReleaseVersion[]

  @@map("releases")
}

model ReleaseVersion {
  version    String             @id
  release_id Int
  created_at DateTime?
  release    Release            @relation(fields: [release_id], references: [id], onDelete: Cascade)
  components ReleaseComponent[]

  @@map("release_versions")
}

model ProductVersion {
  id               Int                @id @default(autoincrement())
  product_id       Int
  version          String
  product          Product            @relation(fields: [product_id], references: [id], onDelete: Cascade)
  ProductLifecycle ProductLifecycle[]
  ReleaseComponent ReleaseComponent[]

  @@unique([version, product_id])
  @@map("product_versions")
}

model ProductLifecycle {
  product_version_id  Int
  release_id          Int
  support_status      SupportStatus
  rel_product_version ProductVersion @relation(fields: [product_version_id], references: [id])
  rel_release_id      Release        @relation(fields: [release_id], references: [id])

  @@unique([release_id, product_version_id])
  @@map("product_lifecycles")
}

model ReleaseComponent {
  product_version_id  Int
  release_version     String
  purl                String
  rel_product_version ProductVersion @relation(fields: [product_version_id], references: [id])
  rel_release_version ReleaseVersion @relation(fields: [release_version], references: [version])

  @@unique([purl, release_version])
  @@map("release_components")
}

enum ImplementationStatus {
  NOT_PLANNED
  PLANNED
  IN_PROGRESS
  COMPLETED
  NOT_AVAILABLE
}

enum SupportStatus {
  LONG_TERM_SUPPORT
  GENERAL_AVAILABILITY
  DEPRECATED
  END_OF_LIFE
}
